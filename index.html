<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Scene with GLB</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at top, #19294a 0%, #050611 55%, #020309 100%);
    }
    canvas { display:block; width:100%; height:100%; }
  </style>
</head>
<body>
<canvas id="scene"></canvas>

<!-- Three.js + GLTFLoader + OrbitControls -->
<script src="https://unpkg.com/three@0.161.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.161.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://unpkg.com/three@0.161.0/examples/js/controls/OrbitControls.js"></script>

<script>
(function () {
  const canvas   = document.getElementById('scene');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.75));
  renderer.setClearColor(0x050611, 1);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x050611, 0.045);

  const camera = new THREE.PerspectiveCamera(
    40,
    window.innerWidth / window.innerHeight,
    0.1,
    100
  );
  camera.position.set(0, 3.4, 7.0);

  /* ---------------------------- LIGHTS ---------------------------- */
  const hemi = new THREE.HemisphereLight(0xffffff, 0x111122, 0.9);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(4, 8, 4);
  dir.castShadow = true;
  dir.shadow.mapSize.set(1024, 1024);
  dir.shadow.camera.near = 1;
  dir.shadow.camera.far  = 20;
  scene.add(dir);

  /* ---------------------------- FLOOR ---------------------------- */
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(20,20),
    new THREE.MeshStandardMaterial({
      color:0x14151e,
      roughness:0.9,
      metalness:0.05
    })
  );
  floor.rotation.x = -Math.PI/2;
  floor.receiveShadow = true;
  scene.add(floor);

  /* ---------------------------- SMALL ORBS ---------------------------- */
  const decoGroup = new THREE.Group();
  scene.add(decoGroup);

  const palette = [0xf2f4ff, 0xffc6a5, 0x9dd6ff, 0xffe66d, 0xd0b3ff];

  for (let i = 0; i < 6; i++) {
    const geo = new THREE.SphereGeometry(0.22 + Math.random()*0.18, 32, 32);
    const mat = new THREE.MeshStandardMaterial({
      color: palette[i % palette.length],
      roughness:0.4,
      metalness:0.3
    });
    const m = new THREE.Mesh(geo, mat);
    m.position.set(
      (Math.random()-0.5)*3,
      1.4 + Math.random()*0.6,
      (Math.random()-0.5)*2
    );
    m.castShadow = true;
    m.receiveShadow = true;
    m.userData.spin = (Math.random()*0.6)+0.4;
    decoGroup.add(m);
  }

  /* ---------------------------- GLB LOADER ---------------------------- */

  const loader = new THREE.GLTFLoader();

  function loadGLB(url, pos, scale, rotY = 0){
    loader.load(
      url,
      gltf => {
        const model = gltf.scene;
        model.position.set(pos[0], pos[1], pos[2]);
        model.scale.set(scale, scale, scale);
        model.rotation.y = rotY;

        model.traverse(obj => {
          if (obj.isMesh) {
            obj.castShadow = true;
            obj.receiveShadow = true;
            if (obj.material && !Array.isArray(obj.material)) {
              obj.material.envMapIntensity = 1.0;
            }
          }
        });

        model.userData.rotate = true;
        scene.add(model);
      },
      undefined,
      err => {
        console.error("GLB load error:", url, err);
      }
    );
  }

  /* ---------- YOUR MODELS (GLB) ---------- */
  loadGLB(
    "https://raw.githubusercontent.com/archysketch/3dscene/main/christmas_ball.glb",
    [-1.1, 0.0, 0.0],
    1.3,
    Math.PI * 0.15
  );

  loadGLB(
    "https://raw.githubusercontent.com/archysketch/3dscene/main/christmas_tree_ball.glb",
    [1.2, 0.0, -0.4],
    1.3,
    -Math.PI * 0.1
  );
  /* --------------------------------------- */

  /* ---------------------------- MOUSE / CAMERA ---------------------------- */

  let mouseX = 0, mouseY = 0;
  let targetRotX = 0, targetRotY = 0;

  window.addEventListener("pointermove", e => {
    mouseX = (e.clientX / window.innerWidth) * 2 - 1;
    mouseY = (e.clientY / window.innerHeight) * 2 - 1;
    targetRotY = mouseX * 0.4;
    targetRotX = mouseY * 0.15;
  });

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.07;
  controls.enablePan = false;
  controls.maxPolarAngle = Math.PI / 2.1;
  controls.minDistance = 4;
  controls.maxDistance = 10;
  controls.target.set(0, 1.0, 0);

  /* ---------------------------- RESIZE ---------------------------- */

  function resize(){
    const w = window.innerWidth;
    const h = window.innerHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener("resize", resize);
  resize();

  /* ---------------------------- ANIMATE ---------------------------- */

  function animate(){
    requestAnimationFrame(animate);

    // sahneye mouse ile hafif tilt
    decoGroup.rotation.y += (targetRotY - decoGroup.rotation.y) * 0.04;
    decoGroup.rotation.x += (targetRotX - decoGroup.rotation.x) * 0.03;

    // küçük toplar döner
    decoGroup.children.forEach(m => {
      m.rotation.y += 0.01 * m.userData.spin;
    });

    // GLB modelleri yavaşça döndür
    scene.traverse(obj => {
      if (obj.userData.rotate) {
        obj.rotation.y += 0.005;
      }
    });

    controls.update();
    renderer.render(scene, camera);
  }
  animate();

})();
</script>
</body>
</html>
