<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Lusion Organic Physics v4</title>
<style>
  html, body { margin: 0; padding: 0; overflow: hidden; background: black; }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
// ---------------------------------------------
// SCENE
// ---------------------------------------------
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 200);
camera.position.set(0, 0, 40);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

// ---------------------------------------------
// LIGHT
// ---------------------------------------------
scene.add(new THREE.AmbientLight(0xffffff, 0.55));
const directional = new THREE.DirectionalLight(0xffffff, 0.8);
directional.position.set(3, 5, 7);
scene.add(directional);

// ---------------------------------------------
// PARAMETERS
// ---------------------------------------------
const COUNT = 38;
const RADIUS = 2.4;              // büyüklük artırıldı
const COLLISION_DIST = RADIUS * 2.05;  // iç içe girme yok
const MOUSE_FORCE = 0.14;        // vurma kuvveti
const IDLE_DRIFT = 0.004;        // bağımsız küçük drift
const DAMPING = 0.93;

// ---------------------------------------------
// CREATE BALL INSTANCES
// ---------------------------------------------
const geometry = new THREE.SphereGeometry(RADIUS, 32, 32);
const material = new THREE.MeshStandardMaterial({
  color: 0x4064ff,
  roughness: 0.22,
  metalness: 0.18
});

const balls = new THREE.InstancedMesh(geometry, material, COUNT);
scene.add(balls);

const pos = [];
const vel = [];
const drift = [];
const temp = new THREE.Object3D();

// INITIAL POSITIONS
for (let i = 0; i < COUNT; i++) {
  pos[i] = new THREE.Vector3(
    (Math.random()-0.5) * 20,
    (Math.random()-0.5) * 14,
    (Math.random()-0.5) * 12
  );

  // başlangıç hareketi
  vel[i] = new THREE.Vector3(
    (Math.random()-0.5) * 0.04,
    (Math.random()-0.5) * 0.04,
    (Math.random()-0.5) * 0.04
  );

  // bağımsız idle drift
  drift[i] = new THREE.Vector3(
    (Math.random()-0.5) * IDLE_DRIFT,
    (Math.random()-0.5) * IDLE_DRIFT,
    (Math.random()-0.5) * IDLE_DRIFT
  );
}

// ---------------------------------------------
// MOUSE FORCE
// ---------------------------------------------
let mouse = new THREE.Vector3();

window.addEventListener("pointermove", e => {
  const x = (e.clientX / innerWidth) * 2 - 1;
  const y = -(e.clientY / innerHeight) * 2 + 1;
  mouse.set(x * 14, y * 9, 0);
});

function applyMouseImpulse() {
  for (let i = 0; i < COUNT; i++) {
    const diff = pos[i].clone().sub(mouse);
    const dist = diff.length();

    if (dist < 6) {
      diff.normalize();
      vel[i].add(diff.multiplyScalar((6 - dist) * MOUSE_FORCE));
    }
  }
}

// ---------------------------------------------
// PHYSICS
// ---------------------------------------------
function updatePhysics() {

  // 1. Bağımsız drift (organik hareket)
  for (let i = 0; i < COUNT; i++) {
    pos[i].add(drift[i]);
  }

  // 2. Top-top çarpışmaları
  for (let i = 0; i < COUNT; i++) {
    for (let j = i + 1; j < COUNT; j++) {

      const diff = pos[i].clone().sub(pos[j]);
      const dist = diff.length();

      if (dist < COLLISION_DIST && dist > 0) {

        const push = (COLLISION_DIST - dist) * 0.065;
        diff.normalize();

        vel[i].add(diff.clone().multiplyScalar(push));
        vel[j].add(diff.clone().multiplyScalar(-push));
      }
    }
  }

  // 3. Mouse çarpma efekti
  applyMouseImpulse();

  // 4. Hız ve konum güncelle
  for (let i = 0; i < COUNT; i++) {
    vel[i].multiplyScalar(DAMPING);
    pos[i].add(vel[i]);
  }
}

// ---------------------------------------------
// RENDER LOOP
// ---------------------------------------------
function animate() {

  updatePhysics();

  // instanced mesh matrix güncelle
  for (let i = 0; i < COUNT; i++) {
    temp.position.copy(pos[i]);
    temp.updateMatrix();
    balls.setMatrixAt(i, temp.matrix);
  }
  balls.instanceMatrix.needsUpdate = true;

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

// ---------------------------------------------
window.addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
