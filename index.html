<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Lusion Advanced Physics</title>
<style>
  html, body { margin: 0; padding: 0; overflow: hidden; background: #000; }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
// ---------------------------------------------------------
// SCENE
// ---------------------------------------------------------
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a0e1a, 0.035);  // ✨ VOLUMETRIC FOG GLOW

const camera = new THREE.PerspectiveCamera(
  55, innerWidth / innerHeight, 0.1, 200
);
camera.position.set(0, 0, 32);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

// ---------------------------------------------------------
// LIGHTING
// ---------------------------------------------------------
scene.add(new THREE.AmbientLight(0xffffff, 0.25));

const dir = new THREE.DirectionalLight(0xffffff, 1.4); // ✨ wide area-like light
dir.position.set(-3, 4, 8);
scene.add(dir);

// SOFT area-like fill light
const areaLight = new THREE.PointLight(0x2040ff, 1, 80);
areaLight.position.set(6, -3, 4);
scene.add(areaLight);

// ---------------------------------------------------------
// PARAMETERS
// ---------------------------------------------------------
const COUNT = 38;
const BALL_RADIUS = 2.0;
const COLLISION_DIST = BALL_RADIUS * 2.2;
const CENTER_FORCE = 0.0012;
const REPEL_FORCE = 0.03;
const DAMPING = 0.965;
const IDLE_VARIATION = 0.015;

const positions = [];
const velocities = [];
const drift = [];
const driftSpeed = [];

const temp = new THREE.Object3D();

// ---------------------------------------------------------
// CUSTOM MATERIAL (✨ FRESNEL + GRADIENT LIKE LUSION)
// ---------------------------------------------------------
const gradientMaterial = new THREE.ShaderMaterial({
  uniforms: {
    u_color1: { value: new THREE.Color(0x3f63ff) },
    u_color2: { value: new THREE.Color(0x88aaff) },
    u_fresnel: { value: 2.2 },
  },
  vertexShader: `
    varying vec3 vNormal;
    varying vec3 vWorldPos;

    void main() {
      vNormal = normalize(normalMatrix * normal);
      vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
      gl_Position = projectionMatrix * viewMatrix * vec4(vWorldPos, 1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 u_color1;
    uniform vec3 u_color2;
    uniform float u_fresnel;

    varying vec3 vNormal;
    varying vec3 vWorldPos;

    void main() {

      // base gradient
      float height = vWorldPos.y * 0.08 + 0.5;
      vec3 base = mix(u_color1, u_color2, height);

      // fresnel glow
      float f = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), u_fresnel);
      vec3 glow = vec3(0.5,0.6,1.0) * f * 1.2;

      gl_FragColor = vec4(base + glow, 1.0);
    }
  `,
});

// ---------------------------------------------------------
// BALL INSTANCING
// ---------------------------------------------------------
const geometry = new THREE.SphereGeometry(BALL_RADIUS, 48, 48);
const balls = new THREE.InstancedMesh(geometry, gradientMaterial, COUNT);
scene.add(balls);

// ---------------------------------------------------------
// INITIALIZE POSITIONS
// ---------------------------------------------------------
for (let i = 0; i < COUNT; i++) {

  positions[i] = new THREE.Vector3(
    (Math.random() - 0.5) * 10,
    (Math.random() - 0.5) * 7,
    (Math.random() - 0.5) * 7
  );

  velocities[i] = new THREE.Vector3(
    (Math.random() - 0.5) * 0.02,
    (Math.random() - 0.5) * 0.02,
    (Math.random() - 0.5) * 0.02
  );

  drift[i] = new THREE.Vector3(
    Math.random() * 5,
    Math.random() * 5,
    Math.random() * 5
  );

  driftSpeed[i] = 0.002 + Math.random() * 0.003;
}

// ---------------------------------------------------------
// MOUSE FORCE
// ---------------------------------------------------------
let mouse = new THREE.Vector3();

window.addEventListener("pointermove", e => {
  const x = (e.clientX / innerWidth) * 2 - 1;
  const y = -(e.clientY / innerHeight) * 2 + 1;
  mouse.set(x * 14, y * 9, 0);
});

function applyMouseImpulse() {
  const radius = 8;
  const force = 0.065;

  for (let i = 0; i < COUNT; i++) {
    const diff = positions[i].clone().sub(mouse);
    const dist = diff.length();

    if (dist < radius) {
      diff.normalize();
      velocities[i].addScaledVector(diff, (radius - dist) * force);
    }
  }
}

// ---------------------------------------------------------
// PHYSICS UPDATE
// ---------------------------------------------------------
function updatePhysics(time) {

  for (let i = 0; i < COUNT; i++) {

    // ✨ micro drift (güzel akış)
    positions[i].x += Math.sin(time * driftSpeed[i] + drift[i].x) * IDLE_VARIATION;
    positions[i].y += Math.cos(time * driftSpeed[i] + drift[i].y) * IDLE_VARIATION;
    positions[i].z += Math.sin(time * driftSpeed[i] + drift[i].z) * IDLE_VARIATION;

    // center pull
    velocities[i].addScaledVector(positions[i], -CENTER_FORCE);

    // collisions
    for (let j = i + 1; j < COUNT; j++) {

      const diff = positions[i].clone().sub(positions[j]);
      const dist = diff.length();

      if (dist < COLLISION_DIST && dist > 0) {

        const push = (COLLISION_DIST - dist) * REPEL_FORCE;

        diff.normalize();
        velocities[i].addScaledVector(diff, push);
        velocities[j].addScaledVector(diff, -push);
      }
    }

    velocities[i].multiplyScalar(DAMPING);
    positions[i].add(velocities[i]);
  }
}

// ---------------------------------------------------------
// CAMERA WOBBLE ✨
// ---------------------------------------------------------
function updateCamera(time) {
  camera.position.x = Math.sin(time * 0.15) * 0.35;
  camera.position.y = Math.cos(time * 0.12) * 0.25;
  camera.lookAt(0, 0, 0);
}

// ---------------------------------------------------------
// RENDER LOOP
// ---------------------------------------------------------
function animate(t) {
  const time = t * 0.001;

  applyMouseImpulse();
  updatePhysics(time);
  updateCamera(time);  // ✨ ultra subtle wobble

  for (let i = 0; i < COUNT; i++) {
    temp.position.copy(positions[i]);
    temp.updateMatrix();
    balls.setMatrixAt(i, temp.matrix);
  }
  balls.instanceMatrix.needsUpdate = true;

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

// ---------------------------------------------------------
window.addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
