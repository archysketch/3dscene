<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Lusion Style Smooth 3D Balls</title>

  <style>
    html,body{
      margin:0;
      padding:0;
      overflow:hidden;
      height:100%;
      background:
        radial-gradient(circle at 50% 0%, #1e3d72 0%, #050713 55%, #000000 100%);
    }
    canvas{display:block;}
    #hint{
      position:fixed;
      left:50%;
      bottom:16px;
      transform:translateX(-50%);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      font-size:10px;
      letter-spacing:0.18em;
      text-transform:uppercase;
      color:rgba(255,255,255,0.4);
      pointer-events:none;
    }
  </style>
</head>

<body>

<div id="hint">MOVE MOUSE · DRAG · SCROLL</div>

<!-- three.js (global THREE) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.126.1/build/three.min.js"></script>
<!-- GLTFLoader -->
<script src="https://cdn.jsdelivr.net/npm/three@0.126.1/examples/js/loaders/GLTFLoader.js"></script>

<script>
/* -----------------------------------------------------------
   SCENE / CAMERA / RENDERER
----------------------------------------------------------- */
let scene = new THREE.Scene();

let camera = new THREE.PerspectiveCamera(
  35,
  window.innerWidth / window.innerHeight,
  0.1,
  100
);
camera.position.set(0, 0, 18);

let renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio || 1);
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.setClearColor(0x000000, 0);
document.body.appendChild(renderer.domElement);

/* -----------------------------------------------------------
   LIGHTS
----------------------------------------------------------- */
scene.add(new THREE.HemisphereLight(0x88aaff, 0x050506, 0.7));

let key = new THREE.DirectionalLight(0xffffff, 1.4);
key.position.set(6, 8, 10);
scene.add(key);

let rim = new THREE.PointLight(0x3c7bff, 2.3, 80);
rim.position.set(-7, -3, 8);
scene.add(rim);

/* -----------------------------------------------------------
   GROUP + BODIES
----------------------------------------------------------- */
let group = new THREE.Group();
scene.add(group);

let bodies = []; // { mesh, velocity }

let loader = new THREE.GLTFLoader();

/* -----------------------------------------------------------
   GLB → CLONES
----------------------------------------------------------- */
function createBodies(gltf, count, baseScale, spread) {
  for (let i = 0; i < count; i++) {
    let clone = gltf.scene.clone(true);

    clone.traverse(obj => {
      if (obj.isMesh && obj.material) {
        obj.material.metalness = 0.45;
        obj.material.roughness = 0.25;
      }
    });

    let s = baseScale * (0.7 + Math.random() * 0.8);
    clone.scale.set(s, s, s);

    clone.position.set(
      (Math.random()*2-1)*spread.x,
      (Math.random()*2-1)*spread.y,
      (Math.random()*2-1)*spread.z
    );

    group.add(clone);

    bodies.push({
      mesh: clone,
      velocity: new THREE.Vector3(
        (Math.random()*2-1)*0.01,
        (Math.random()*2-1)*0.01,
        (Math.random()*2-1)*0.01
      )
    });
  }
}

/* -----------------------------------------------------------
   LOAD MODELS
----------------------------------------------------------- */
let loaded = 0;
const TOTAL = 2;

loader.load("christmas_ball.glb", gltf => {
  createBodies(gltf, 10, 0.9, {x:5,y:3,z:3});
  if (++loaded === TOTAL) start();
});

loader.load("christmas_tree_ball.glb", gltf => {
  createBodies(gltf, 8, 1.1, {x:5,y:3,z:3});
  if (++loaded === TOTAL) start();
});

/* -----------------------------------------------------------
   MOUSE + SCROLL
----------------------------------------------------------- */
let mouseNorm = new THREE.Vector2(0,0);
let scrollOffset = 0;

window.addEventListener("pointermove", e => {
  mouseNorm.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouseNorm.y = (e.clientY / window.innerHeight) * 2 - 1;
});

window.addEventListener("wheel", e => {
  scrollOffset += e.deltaY * 0.0007;
  scrollOffset = Math.max(-2, Math.min(2, scrollOffset));
}, { passive:true });

/* -----------------------------------------------------------
   LUSION STYLE PHYSICS ENGINE
----------------------------------------------------------- */
function applyLusionPhysics(dt)
{
  let R = 5.0;                    // sphere radius
  let repelRadius = 2.4;         // object-object repel area
  let mouseRadius = 3.0;         // mouse influence
  let damping = 0.92;
  let centerForce = 0.15;
  let repelForce = 0.035;
  let mouseForce = 0.18;

  let mouseWorld = new THREE.Vector3(
    mouseNorm.x * 4.5,
    -mouseNorm.y * 3.0,
    0
  );

  // soft neighbor repel
  for (let i=0;i<bodies.length;i++){
    for (let j=i+1;j<bodies.length;j++){
      let bi=bodies[i], bj=bodies[j];
      let d = bi.mesh.position.clone().sub(bj.mesh.position);
      let dist = d.length();
      if(dist>0 && dist<repelRadius){
        let f = (repelRadius - dist) * repelForce;
        d.normalize();
        bi.velocity.addScaledVector(d,  f);
        bj.velocity.addScaledVector(d, -f);
      }
    }
  }

  // each body
  for (let b of bodies){
    let p=b.mesh.position, v=b.velocity;

    // spherical shell constraint
    let radial = p.length();
    if(radial>0){
      let diff = radial - R;
      let n = p.clone().normalize();
      v.addScaledVector(n, -diff * centerForce);
    }

    // mouse repel
    let mvec = p.clone().sub(mouseWorld);
    let md = mvec.length();
    if (md > 0 && md < mouseRadius){
      let f = (mouseRadius - md) * mouseForce;
      mvec.normalize();
      v.addScaledVector(mvec, f);
    }

    // tiny noise
    v.x += (Math.random()-0.5)*0.001;
    v.y += (Math.random()-0.5)*0.001;
    v.z += (Math.random()-0.5)*0.001;

    // damping
    v.multiplyScalar(damping);

    // position
    p.addScaledVector(v, dt*60);

    // smooth rotation
    b.mesh.rotation.x += 0.25*dt;
    b.mesh.rotation.y += 0.35*dt;
  }
}

/* -----------------------------------------------------------
   ANIMATION LOOP
----------------------------------------------------------- */
let last = performance.now();
let running = false;

function start(){
  running = true;
  last = performance.now();
  animate();
}

function animate(){
  requestAnimationFrame(animate);
  if (!running) return;

  let now = performance.now();
  let dt = Math.min(0.04, (now-last)/1000);
  last = now;

  applyLusionPhysics(dt);

  // smooth zoom
  let targetZ = 18 + scrollOffset * 3;
  camera.position.z += (targetZ - camera.position.z)*0.06;

  camera.lookAt(0,0,0);
  renderer.render(scene,camera);
}

/* -----------------------------------------------------------
   RESIZE
----------------------------------------------------------- */
window.addEventListener("resize",()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
