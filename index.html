<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Lusion Style Motion</title>
<style>
    html,body{
        margin:0; padding:0; overflow:hidden;
        background: radial-gradient(circle at 50% 0%, #1e3d72 0%, #050713 55%, #000000 100%);
    }
    canvas{display:block;}
    #hint{
        position:fixed; left:50%; bottom:20px; transform:translateX(-50%);
        color:#fff4; font-size:10px; letter-spacing:3px; font-family:sans-serif;
    }
</style>
</head>
<body>

<div id="hint">MOVE MOUSE · DRAG</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.126.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.126.1/examples/js/loaders/GLTFLoader.js"></script>

<script>
/* =============================
   SCENE SETUP
============================= */
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(35, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0,0,18);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* LIGHTS */
scene.add(new THREE.HemisphereLight(0x99bbff,0x050505,0.9));
let dir = new THREE.DirectionalLight(0xffffff,1.4);
dir.position.set(4,6,10);
scene.add(dir);

/* =============================
   PARAMETERS
============================= */
const COUNT1 = 10;
const COUNT2 = 8;
const RADIUS = 6;              // hacim yarıçapı
const AVOID_DIST = 1.8;        // iç içe girmeyi engelle
const AVOID_FORCE = 0.06;
const TARGET_SHIFT = 0.008;    // hedef değişme hızı
const EASE = 0.08;             // easing kuvveti
const ROT = 0.01;

/* =============================
   OBJECT STORAGE
============================= */
let balls = [];
let mouse = new THREE.Vector3();

/* =============================
   LOAD MODELS
============================= */
const loader = new THREE.GLTFLoader();
let loadCount = 0;

loader.load("christmas_ball.glb", gltf=>{
    makeObjects(gltf, COUNT1);
});
loader.load("christmas_tree_ball.glb", gltf=>{
    makeObjects(gltf, COUNT2);
});

function makeObjects(gltf, count){
    for(let i=0;i<count;i++){
        let mesh = gltf.scene.clone(true);

        mesh.scale.setScalar(0.8 + Math.random()*0.6);

        scene.add(mesh);

        balls.push({
            mesh,
            target: randomPos(),
            velocity: new THREE.Vector3()
        });
    }
    if(++loadCount === 2) animate();
}

/* =============================
   HELPERS
============================= */
function randomPos(){
    return new THREE.Vector3(
        (Math.random()*2-1) * RADIUS,
        (Math.random()*2-1) * (RADIUS*0.6),
        (Math.random()*2-1) * (RADIUS*0.6)
    );
}

/* =============================
   MOUSE INTERACTION
============================= */
addEventListener("pointermove", e=>{
    mouse.x = (e.clientX / innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / innerHeight) * 2 + 1;
    mouse.z = 0;
});

/* =============================
   ANIMATION LOOP
============================= */
function animate(){
    requestAnimationFrame(animate);

    balls.forEach(b=>{
        let m = b.mesh;

        // hedef pozisyonu zamanla değiştir (lusion tarzı)
        b.target.x += (Math.random()-0.5) * TARGET_SHIFT;
        b.target.y += (Math.random()-0.5) * TARGET_SHIFT;
        b.target.z += (Math.random()-0.5) * TARGET_SHIFT;

        // easing ile hedefe yaklaşma
        let toTarget = b.target.clone().sub(m.position).multiplyScalar(EASE);
        b.velocity.add(toTarget);

        // mouse etkisi
        let mp = m.position.clone().sub(mouseWorld());
        let d = mp.length();
        if(d < 3){
            mp.normalize();
            b.velocity.add(mp.multiplyScalar((3-d)*0.04));
        }

        // iç içe girmeyi engelle — repulsion
        balls.forEach(other=>{
            if(other === b) return;
            let diff = m.position.clone().sub(other.mesh.position);
            let dist = diff.length();
            if(dist < AVOID_DIST && dist > 0){
                diff.normalize();
                b.velocity.add(diff.multiplyScalar(AVOID_FORCE));
            }
        });

        // pozisyon güncelle
        m.position.add(b.velocity);
        b.velocity.multiplyScalar(0.94);

        // yumuşak dönüş
        m.rotation.x += ROT;
        m.rotation.y += ROT*1.5;
    });

    renderer.render(scene,camera);
}

function mouseWorld(){
    return new THREE.Vector3(mouse.x*4, mouse.y*3, 0);
}

/* RESIZE */
addEventListener("resize",()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
