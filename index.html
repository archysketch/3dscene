<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>3D Scene – GLB Balls</title>
  <style>
    html,body{
      margin:0;
      padding:0;
      overflow:hidden;
      height:100%;
      background:
        radial-gradient(circle at 50% 0%, #1b3b6b 0%, #02030a 55%, #000000 100%);
    }
    canvas{display:block;}
    #hint{
      position:fixed;
      left:50%;
      bottom:16px;
      transform:translateX(-50%);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      font-size:10px;
      letter-spacing:0.18em;
      text-transform:uppercase;
      color:rgba(255,255,255,0.35);
      pointer-events:none;
    }
  </style>
</head>
<body>

  <div id="hint">MOVE &middot; DRAG &middot; SCROLL</div>

  <!-- three.js (r126, global THREE) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.126.1/build/three.min.js"></script>
  <!-- GLTFLoader (aynı sürüm, THREE.GLTFLoader olarak) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.126.1/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    // ==== SCENE / CAMERA / RENDERER ====
    var scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.12);

    var camera = new THREE.PerspectiveCamera(
      35,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    camera.position.set(0, 0, 18);

    var renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.setClearColor(0x000000, 0); // arka planda CSS gradient’i görünsün
    document.body.appendChild(renderer.domElement);

    // ==== LIGHTS ====
    var ambLight = new THREE.AmbientLight(0xffffff, 0.35);
    scene.add(ambLight);

    var keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
    keyLight.position.set(6, 8, 10);
    scene.add(keyLight);

    var rimLight = new THREE.PointLight(0x448aff, 1.8, 80);
    rimLight.position.set(-6, -4, 6);
    scene.add(rimLight);

    // ==== GROUP & "PHYSICS" ====
    var group = new THREE.Group();
    scene.add(group);

    var bodies = []; // { mesh, velocity: THREE.Vector3, floatPhase:number }
    var bounds = { x: 8.5, y: 5.0, z: 5.0 };

    var loader = new THREE.GLTFLoader();

    // GLB'den birden fazla kopya üret
    function createBodiesFromGLTF(gltf, count, baseScale, spread) {
      for (var i = 0; i < count; i++) {
        var clone = gltf.scene.clone(true);

        clone.traverse(function(obj){
          if (obj.isMesh && obj.material) {
            obj.castShadow = false;
            obj.receiveShadow = false;
            obj.material.metalness = 0.4;
            obj.material.roughness = 0.25;
          }
        });

        var s = baseScale * (0.7 + Math.random() * 0.8);
        clone.scale.set(s, s, s);

        clone.position.set(
          (Math.random() * 2 - 1) * spread.x,
          (Math.random() * 2 - 1) * spread.y,
          (Math.random() * 2 - 1) * spread.z
        );

        group.add(clone);

        var v = new THREE.Vector3(
          (Math.random() * 2 - 1) * 0.05,
          (Math.random() * 2 - 1) * 0.05,
          (Math.random() * 2 - 1) * 0.05
        );

        bodies.push({
          mesh: clone,
          velocity: v,
          floatPhase: Math.random() * Math.PI * 2
        });
      }
    }

    // ==== GLB LOADS ====
    var assetsLoaded = 0;
    var TOTAL_ASSETS = 2;

    loader.load(
      "christmas_ball.glb",
      function(gltf){
        createBodiesFromGLTF(
          gltf,
          10,                       // kaç tane kırmızı
          0.9,                      // ölçek
          { x: 6, y: 3.5, z: 3 }
        );
        assetsLoaded++;
        if (assetsLoaded === TOTAL_ASSETS) start();
      },
      undefined,
      function(err){ console.error("Ball load ERROR:", err); }
    );

    loader.load(
      "christmas_tree_ball.glb",
      function(gltf){
        createBodiesFromGLTF(
          gltf,
          8,                        // kaç tane mavi
          1.1,
          { x: 5, y: 3.0, z: 3 }
        );
        assetsLoaded++;
        if (assetsLoaded === TOTAL_ASSETS) start();
      },
      undefined,
      function(err){ console.error("Tree load ERROR:", err); }
    );

    // ==== MOUSE & SCROLL ====
    var mouseNorm = new THREE.Vector2(0, 0); // -1..1
    var scrollOffset = 0;

    window.addEventListener("pointermove", function(e){
      var x = (e.clientX / window.innerWidth) * 2 - 1;
      var y = (e.clientY / window.innerHeight) * 2 - 1;
      mouseNorm.set(x, y);
    });

    window.addEventListener("wheel", function(e){
      scrollOffset += e.deltaY * 0.0007;
      scrollOffset = Math.max(-2, Math.min(2, scrollOffset));
    }, { passive:true });

    // ==== ANIMATION LOOP ====
    var lastTime = performance.now();
    var running = false;

    function start(){
      if (!running){
        running = true;
        lastTime = performance.now();
        animate();
      }
    }

    function animate(){
      requestAnimationFrame(animate);
      if (!running) return;

      var now = performance.now();
      var dt = Math.min(0.04, (now - lastTime) / 1000); // saniye
      lastTime = now;

      updatePhysics(dt);
      updateCamera(dt);

      renderer.render(scene, camera);
    }

    function updatePhysics(dt){
      var mouseForce = 2.0;
      var damping    = 0.985;
      var gravity    = new THREE.Vector3(0, -0.09, 0);

      for (var i = 0; i < bodies.length; i++){
        var b = bodies[i];
        var m = b.mesh;
        var v = b.velocity;

        // hafif kendi rotasyonu
        b.floatPhase += dt;
        m.rotation.y += 0.4 * dt;
        m.rotation.x += 0.17 * dt;

        // yerçekimi
        v.addScaledVector(gravity, dt);

        // mouse çekimi
        var targetX = mouseNorm.x * 4;
        var targetY = -mouseNorm.y * 2.5;
        var mousePos = new THREE.Vector3(targetX, targetY, 0);

        var toMouse = mousePos.clone().sub(m.position);
        var dist = toMouse.length() + 0.001;
        var strength = (mouseForce / (dist * dist + 1));
        toMouse.normalize();
        v.addScaledVector(toMouse, strength * dt);

        // basit birbirini itme
        for (var j = i + 1; j < bodies.length; j++){
          var b2 = bodies[j];
          var m2 = b2.mesh;
          var delta = m.position.clone().sub(m2.position);
          var d = delta.length();
          if (d > 0 && d < 2.0){
            var push = (2.0 - d) * 0.12;
            delta.normalize();
            v.addScaledVector(delta, push * dt);
            b2.velocity.addScaledVector(delta, -push * dt);
          }
        }

        // damping
        v.multiplyScalar(damping);

        // konum
        m.position.addScaledVector(v, dt * 60); // biraz hız çarpanı

        // sınırdan sekme
        if (m.position.x < -bounds.x){ m.position.x = -bounds.x; v.x *= -0.85; }
        if (m.position.x >  bounds.x){ m.position.x =  bounds.x; v.x *= -0.85; }
        if (m.position.y < -bounds.y){ m.position.y = -bounds.y; v.y *= -0.85; }
        if (m.position.y >  bounds.y){ m.position.y =  bounds.y; v.y *= -0.85; }
        if (m.position.z < -bounds.z){ m.position.z = -bounds.z; v.z *= -0.85; }
        if (m.position.z >  bounds.z){ m.position.z =  bounds.z; v.z *= -0.85; }
      }
    }

    function updateCamera(dt){
      // group'u mouse'a göre eğ
      var tiltX = mouseNorm.y * 0.35;
      var tiltY = mouseNorm.x * 0.55;

      group.rotation.x += (tiltX - group.rotation.x) * 0.06;
      group.rotation.y += (tiltY - group.rotation.y) * 0.06;

      // scroll ile hafif zoom
      var targetZ = 18 + scrollOffset * 3;
      camera.position.z += (targetZ - camera.position.z) * 0.06;
      camera.lookAt(0, 0, 0);
    }

    // ==== RESIZE ====
    window.addEventListener("resize", function () {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
