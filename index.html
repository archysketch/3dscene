<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Balls – GitHub/Bubble</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background: radial-gradient(circle at 50% 0%, #15264b 0%, #02030a 55%, #000 100%);
    }
    #scene-container {
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
    }
    /* küçük “MOVE / DRAG / SCROLL” yazısı – Lusion hissi için :) */
    #hint {
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-size: 10px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.35);
      pointer-events: none;
    }
  </style>

  <!-- THREE core (legacy build, non-module) -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <!-- GLTF loader (legacy UMD; THREE.GLTFLoader mevcut) -->
  <script src="https://unpkg.com/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
  <div id="scene-container"></div>
  <div id="hint">MOVE YOUR MOUSE &middot; DRAG &middot; SCROLL</div>

  <script>
    // ---------- TEMEL THREE KURULUMU ----------
    const container = document.getElementById('scene-container');

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.17);

    const camera = new THREE.PerspectiveCamera(
      35,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    camera.position.set(0, 0, 18);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    container.appendChild(renderer.domElement);

    // ---------- IŞIKLAR ----------
    const ambient = new THREE.AmbientLight(0xffffff, 0.35);
    scene.add(ambient);

    const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
    keyLight.position.set(5, 8, 10);
    scene.add(keyLight);

    const rimLight = new THREE.PointLight(0x448aff, 1.3, 60);
    rimLight.position.set(-6, -4, 6);
    scene.add(rimLight);

    // ---------- GRUP & FİZİK BENZERİ ----------
    const group = new THREE.Group();
    scene.add(group);

    const bodies = []; // { mesh, velocity: THREE.Vector3, floatPhase }

    const bounds = {
      x: 8.5,
      y: 5.0,
      z: 5.5
    };

    const loader = new THREE.GLTFLoader();

    function createBodiesFromGLTF(gltf, count, baseScale, spread) {
      for (let i = 0; i < count; i++) {
        const clone = gltf.scene.clone(true);

        // Mesh’leri sRGB’e ve hafif parlaklığa ayarla
        clone.traverse((obj) => {
          if (obj.isMesh) {
            obj.castShadow = false;
            obj.receiveShadow = false;
            if (obj.material) {
              obj.material.metalness = 0.4;
              obj.material.roughness = 0.2;
            }
          }
        });

        const s = baseScale * (0.7 + Math.random() * 0.8);
        clone.scale.setScalar(s);

        clone.position.set(
          (Math.random() * 2 - 1) * spread.x,
          (Math.random() * 2 - 1) * spread.y,
          (Math.random() * 2 - 1) * spread.z
        );

        group.add(clone);

        const vel = new THREE.Vector3(
          (Math.random() * 2 - 1) * 0.03,
          (Math.random() * 2 - 1) * 0.03,
          (Math.random() * 2 - 1) * 0.03
        );

        bodies.push({
          mesh: clone,
          velocity: vel,
          floatPhase: Math.random() * Math.PI * 2
        });
      }
    }

    // İki modeli de yükle, sahneye bas
    let assetsLoaded = 0;
    const TOTAL_ASSETS = 2;

    loader.load('christmas_ball.glb', (gltf) => {
      createBodiesFromGLTF(
        gltf,
        10,                 // kaç tane
        0.9,                // ölçek
        { x: 6, y: 3.5, z: 3 }
      );
      if (++assetsLoaded === TOTAL_ASSETS) start();
    });

    loader.load('christmas_tree_ball.glb', (gltf) => {
      createBodiesFromGLTF(
        gltf,
        8,
        1.1,
        { x: 5, y: 3.0, z: 3 }
      );
      if (++assetsLoaded === TOTAL_ASSETS) start();
    });

    // ---------- MOUSE / SCROLL ETKİSİ ----------
    const mouseNorm = new THREE.Vector2(0, 0);
    let scrollOffset = 0;

    window.addEventListener('pointermove', (e) => {
      const x = (e.clientX / window.innerWidth) * 2 - 1;
      const y = (e.clientY / window.innerHeight) * 2 - 1;
      mouseNorm.set(x, y);
    });

    window.addEventListener('wheel', (e) => {
      scrollOffset += e.deltaY * 0.0007;
      scrollOffset = Math.max(-2, Math.min(2, scrollOffset));
    }, { passive: true });

    // ---------- ANİMASYON DÖNGÜSÜ ----------
    let lastTime = performance.now();

    function start() {
      lastTime = performance.now();
      renderer.setAnimationLoop(animate);
    }

    function animate(now) {
      const dt = Math.min(0.04, (now - lastTime) / 1000); // max 40ms
      lastTime = now;

      updatePhysics(dt);
      updateCamera(dt);

      renderer.render(scene, camera);
    }

    function updatePhysics(dt) {
      const mouseForce = 2.1;
      const damping = 0.985;
      const gravity = new THREE.Vector3(0, -0.09, 0);

      for (let i = 0; i < bodies.length; i++) {
        const b = bodies[i];
        const m = b.mesh;
        const v = b.velocity;

        // hafif “yüzen” hareket
        b.floatPhase += dt;
        m.rotation.y += 0.5 * dt;
        m.rotation.x += 0.2 * dt;

        // yerçekimi
        v.addScaledVector(gravity, dt);

        // mouse çekimi (ekran merkezinde ghostsphere gibi)
        const targetX = mouseNorm.x * 4;
        const targetY = -mouseNorm.y * 2.5;
        const mousePos = new THREE.Vector3(targetX, targetY, 0);

        const toMouse = mousePos.clone().sub(m.position);
        const dist = toMouse.length() + 0.001;
        const strength = (mouseForce / (dist * dist + 1));
        v.addScaledVector(toMouse.normalize(), strength * dt);

        // basit birbirini itme – tam fizik değil ama dağınık tutuyor
        for (let j = i + 1; j < bodies.length; j++) {
          const b2 = bodies[j];
          const m2 = b2.mesh;
          const delta = m.position.clone().sub(m2.position);
          const d = delta.length();
          if (d > 0 && d < 2.0) {
            const push = (2.0 - d) * 0.12;
            delta.normalize();
            v.addScaledVector(delta, push * dt);
            b2.velocity.addScaledVector(delta, -push * dt);
          }
        }

        // hızda sönüm
        v.multiplyScalar(damping);

        // konum güncelle
        m.position.addScaledVector(v, dt * 60); // dt küçük olduğu için biraz çarpan

        // sınırdan sekme
        if (m.position.x < -bounds.x) { m.position.x = -bounds.x; v.x *= -0.85; }
        if (m.position.x >  bounds.x) { m.position.x =  bounds.x; v.x *= -0.85; }
        if (m.position.y < -bounds.y) { m.position.y = -bounds.y; v.y *= -0.85; }
        if (m.position.y >  bounds.y) { m.position.y =  bounds.y; v.y *= -0.85; }
        if (m.position.z < -bounds.z) { m.position.z = -bounds.z; v.z *= -0.85; }
        if (m.position.z >  bounds.z) { m.position.z =  bounds.z; v.z *= -0.85; }
      }
    }

    function updateCamera(dt) {
      // parallax hissi – grup mouse’a göre eğiliyor
      const tiltX = mouseNorm.y * 0.35;
      const tiltY = mouseNorm.x * 0.55;

      group.rotation.x += (tiltX - group.rotation.x) * 0.06;
      group.rotation.y += (tiltY - group.rotation.y) * 0.06;

      // scroll ile hafif zoom
      const targetZ = 18 + scrollOffset * 3;
      camera.position.z += (targetZ - camera.position.z) * 0.06;
      camera.lookAt(0, 0, 0);
    }

    // ---------- RESIZE ----------
    window.addEventListener('resize', () => {
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });
  </script>
</body>
</html>
