<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>GLB Physics FINAL</title>
<style>
html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #000;
}
</style>
</head>
<body>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js";
import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/GLTFLoader.js";

// ------------------------------------------------
// SCENE
// ------------------------------------------------
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 100);
camera.position.set(0, 0, 24);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

// ------------------------------------------------
// LIGHT (GUARANTEED VISIBLE)
// ------------------------------------------------
scene.add(new THREE.AmbientLight(0xffffff, 1.8));

const dir = new THREE.DirectionalLight(0xffffff, 1.5);
dir.position.set(5, 8, 10);
scene.add(dir);

// ------------------------------------------------
// PHYSICS DATA
// ------------------------------------------------
const COUNT = 40;
const objects = [];
const positions = [];
const velocities = [];
const rotations = [];

for (let i = 0; i < COUNT; i++) {
    positions[i] = new THREE.Vector3(
        (Math.random() - 0.5) * 12,
        (Math.random() - 0.5) * 7,
        (Math.random() - 0.5) * 7
    );

    velocities[i] = new THREE.Vector3(
        (Math.random() - 0.5) * 0.04,
        (Math.random() - 0.5) * 0.04,
        (Math.random() - 0.5) * 0.04
    );

    rotations[i] = new THREE.Vector3();
}

// ------------------------------------------------
// MOUSE
// ------------------------------------------------
let mouse = new THREE.Vector3();
window.addEventListener("pointermove", (e) => {
    const x = (e.clientX / innerWidth) * 2 - 1;
    const y = -(e.clientY / innerHeight) * 2 + 1;
    mouse.set(x * 9, y * 6, 0);
});

// ------------------------------------------------
// PHYSICS TUNING
// ------------------------------------------------
const CENTER_FORCE = 0.0007;
const DAMPING = 0.97;

const MOUSE_RADIUS = 9;
const MOUSE_FORCE = 0.08;

const REPEL_RADIUS = 5;
const REPEL_STRENGTH = 0.01;

// ------------------------------------------------
// LOAD GLB ONCE, CLONE MANY
// ------------------------------------------------
const loader = new GLTFLoader();

loader.load(
    "https://raw.githubusercontent.com/archysketch/3dscene/main/christmas_ball.glb",
    (gltf) => {

        gltf.scene.traverse((c) => {
            if (c.isMesh) {
                c.geometry.center();
                c.material = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    metalness: 0.3,
                    roughness: 0.25
                });
            }
        });

        for (let i = 0; i < COUNT; i++) {
            const clone = gltf.scene.clone(true);
            clone.scale.setScalar(8); // ðŸ”¥ kritik
            scene.add(clone);
            objects.push(clone);
        }

        animate();
    }
);

// ------------------------------------------------
// FORCES
// ------------------------------------------------
function applyMouseForce() {
    for (let i = 0; i < COUNT; i++) {
        const diff = positions[i].clone().sub(mouse);
        const dist = diff.length();

        if (dist < MOUSE_RADIUS) {
            diff.normalize();
            velocities[i].add(
                diff.multiplyScalar((MOUSE_RADIUS - dist) * MOUSE_FORCE)
            );
        }
    }
}

function updatePhysics() {

    for (let i = 0; i < COUNT; i++) {

        velocities[i].sub(positions[i].clone().multiplyScalar(CENTER_FORCE));

        for (let j = i + 1; j < COUNT; j++) {
            const diff = positions[i].clone().sub(positions[j]);
            const dist = diff.length();

            if (dist < REPEL_RADIUS && dist > 0) {
                diff.normalize();
                const push = (REPEL_RADIUS - dist) * REPEL_STRENGTH;
                velocities[i].add(diff.clone().multiplyScalar(push));
                velocities[j].add(diff.clone().multiplyScalar(-push));
            }
        }

        velocities[i].multiplyScalar(DAMPING);
        positions[i].add(velocities[i]);

        rotations[i].x += velocities[i].y * 0.5;
        rotations[i].y += velocities[i].x * 0.5;
        rotations[i].z += velocities[i].z * 0.5;
    }
}

// ------------------------------------------------
// LOOP
// ------------------------------------------------
function animate() {

    applyMouseForce();
    updatePhysics();

    for (let i = 0; i < COUNT; i++) {
        const obj = objects[i];
        if (!obj) continue;

        obj.position.copy(positions[i]);
        obj.rotation.set(
            rotations[i].x,
            rotations[i].y,
            rotations[i].z
        );
    }

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}

// ------------------------------------------------
window.addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
