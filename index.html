<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Lusion Physics v10 – Stable</title>
<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
    }
</style>
</head>
<body>

<!-- ⭐ STABLE VERSION: THREE r128 -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>

<script>
// ------------------------------------------------------
// SCENE
// ------------------------------------------------------
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
    55, window.innerWidth / window.innerHeight, 0.1, 200
);
camera.position.set(0, 0, 30);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// ------------------------------------------------------
// LIGHT
// ------------------------------------------------------
const hemi = new THREE.HemisphereLight(0xffffff, 0x000000, 1.1);
scene.add(hemi);

// ------------------------------------------------------
// PARAMETERS
// ------------------------------------------------------
const COUNT = 40;
const positions = [];
const velocities = [];
const drift = [];
const driftSpeed = [];
const sizes = [];
const colors = [];

const temp = new THREE.Object3D();

// COLORS (Lusion style pastel palette)
const palette = [
    0xff6b6b, // soft red
    0xffc94c, // soft yellow
    0x4dd4ff, // sky blue
    0x8ea7ff, // lavender
    0xff8cf4  // pink
];

// ------------------------------------------------------
// GEOMETRY / INSTANCING
// ------------------------------------------------------
const baseGeo = new THREE.SphereGeometry(1, 40, 40);
const baseMat = new THREE.MeshStandardMaterial({ roughness: 0.25, metalness: 0.15 });

const instanced = new THREE.InstancedMesh(baseGeo, baseMat, COUNT);
scene.add(instanced);

// ------------------------------------------------------
// INITIALIZE BALLS
// ------------------------------------------------------
for (let i = 0; i < COUNT; i++) {

    // RANDOM POSITION
    positions[i] = new THREE.Vector3(
        (Math.random() - 0.5) * 12,
        (Math.random() - 0.5) * 8,
        (Math.random() - 0.5) * 8
    );

    // VELOCITY
    velocities[i] = new THREE.Vector3(
        (Math.random() - 0.5) * 0.03,
        (Math.random() - 0.5) * 0.03,
        (Math.random() - 0.5) * 0.03
    );

    // RANDOM DRIFT SEEDS
    drift[i] = new THREE.Vector3(
        Math.random() * 10,
        Math.random() * 10,
        Math.random() * 10
    );

    driftSpeed[i] = 0.001 + Math.random() * 0.002;

    // SIZE VARIATION ⭐ (Lusion look)
    sizes[i] = 1.4 + Math.random() * 1.8;

    // COLOR VARIATION
    colors[i] = palette[Math.floor(Math.random() * palette.length)];
}

// ------------------------------------------------------
// HELPERS
// ------------------------------------------------------
const COLLISION = 3.6;          // dynamic size accounts inside loop
const CENTER_FORCE = 0.001;
const DAMPING = 0.965;

// ------------------------------------------------------
// MOUSE FORCE
// ------------------------------------------------------
let mouse = new THREE.Vector3();

window.addEventListener("pointermove", e => {
    mouse.set(
        (e.clientX / window.innerWidth) * 2 - 1,
        -(e.clientY / window.innerHeight) * 2 + 1,
        0
    );

    mouse.x *= 11;
    mouse.y *= 7;
});

function applyMouseForce() {
    const radius = 7;
    const force = 0.055;

    for (let i = 0; i < COUNT; i++) {
        const diff = positions[i].clone().sub(mouse);
        const dist = diff.length();

        if (dist < radius) {
            velocities[i].add(diff.normalize().multiplyScalar((radius - dist) * force));
        }
    }
}

// ------------------------------------------------------
// PHYSICS CORE
// ------------------------------------------------------
function updatePhysics(time) {

    for (let i = 0; i < COUNT; i++) {

        // ⭐ SMOOTH IDLE DRIFT (Lusion feel)
        positions[i].x += Math.sin(time * 0.9 + drift[i].x) * 0.010;
        positions[i].y += Math.cos(time * 1.1 + drift[i].y) * 0.010;
        positions[i].z += Math.sin(time * 1.3 + drift[i].z) * 0.010;

        // CENTER FORCE
        velocities[i].addScaledVector(positions[i], -CENTER_FORCE);

        // COLLISIONS
        for (let j = i + 1; j < COUNT; j++) {

            const diff = positions[i].clone().sub(positions[j]);
            const dist = diff.length();
            const minDist = sizes[i] + sizes[j] + 0.3;

            if (dist < minDist && dist > 0) {

                const push = (minDist - dist) * 0.03;
                diff.normalize();

                velocities[i].addScaledVector(diff, push);
                velocities[j].addScaledVector(diff, -push);
            }
        }

        // DAMPING
        velocities[i].multiplyScalar(DAMPING);

        // APPLY VELOCITY
        positions[i].add(velocities[i]);
    }
}

// ------------------------------------------------------
// CAMERA MICRO MOTION
// ------------------------------------------------------
function updateCamera(time) {
    camera.position.x = Math.sin(time * 0.14) * 0.35;
    camera.position.y = Math.cos(time * 0.17) * 0.35;
    camera.lookAt(0, 0, 0);
}

// ------------------------------------------------------
// RENDER LOOP
// ------------------------------------------------------
function animate(t) {

    const time = t * 0.001;

    applyMouseForce();
    updatePhysics(time);
    updateCamera(time);

    for (let i = 0; i < COUNT; i++) {

        temp.position.copy(positions[i]);
        temp.scale.set(sizes[i], sizes[i], sizes[i]);

        // COLOR PER INSTANCE
        const c = new THREE.Color(colors[i]);
        temp.updateMatrix();
        instanced.setMatrixAt(i, temp.matrix);
        instanced.setColorAt(i, c);
    }

    instanced.instanceMatrix.needsUpdate = true;
    instanced.instanceColor.needsUpdate = true;

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}
animate();

// ------------------------------------------------------
window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
