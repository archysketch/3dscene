<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>3D Cloud</title>
  <style>
    body{
      margin:0;
      overflow:hidden;
      background:radial-gradient(circle at center,#10264a,#000);
    }
    canvas{ display:block; }
  </style>
</head>
<body>

<div style="position:fixed;bottom:10px;left:50%;transform:translateX(-50%);color:#999;font-size:10px;letter-spacing:2px;">
  MOVE • DRAG • FLING
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.126.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.126.1/examples/js/loaders/GLTFLoader.js"></script>

<script>

// =========================================================
// SCENE / CAMERA / RENDERER
// =========================================================
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  45,
  window.innerWidth / window.innerHeight,
  0.1,
  200
);
camera.position.set(0, 0.8, 11);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// =========================================================
// LIGHTS — daha nötr aydınlatma, kararma yok
// =========================================================
scene.add(new THREE.AmbientLight(0xffffff, 0.7));

const dir = new THREE.DirectionalLight(0xffffff, 1.8);
dir.position.set(4,4,6);
scene.add(dir);

const rim = new THREE.DirectionalLight(0x88bbff, 0.9);
rim.position.set(-5,3,-5);
scene.add(rim);

// =========================================================
// GLTF LOADER
// =========================================================
const loader = new THREE.GLTFLoader();

let ballTemplate = null;
let treeTemplate = null;

let ballR = 0.8;
let treeR = 0.8;

let ready = 0;

function computeRadius(object){
  const box = new THREE.Box3().setFromObject(object);
  const size = new THREE.Vector3();
  box.getSize(size);
  return Math.max(size.x,size.y,size.z) * 0.5;
}

function loadModel(url, callback){
  loader.load(
    url,
    gltf => callback(gltf.scene),
    undefined,
    err => console.error("LOAD ERROR:", err)
  );
}

loadModel("christmas_ball.glb", model=>{
  ballTemplate = model;
  ballTemplate.visible = false;
  ballTemplate.scale.set(1.2,1.2,1.2);
  scene.add(ballTemplate);
  ballR = computeRadius(ballTemplate);
  done();
});

loadModel("christmas_tree_ball.glb", model=>{
  treeTemplate = model;
  treeTemplate.visible = false;
  treeTemplate.scale.set(1.2,1.2,1.2);
  scene.add(treeTemplate);
  treeR = computeRadius(treeTemplate);
  done();
});

function done(){
  ready++;
  if(ready===2){
    spawnCloud();
    animate();
  }
}

// =========================================================
// INSTANCE DATA
// =========================================================
let instances = [];

function spawnCloud(){

  const COUNT = 14;
  const cloudR = 3.2;

  for(let i=0;i<COUNT;i++){
    const isBall = Math.random() < 0.5;
    const template = isBall ? ballTemplate : treeTemplate;
    const baseR = isBall ? ballR : treeR;

    const obj = template.clone(true);
    obj.visible = true;

    const s = 1.05 + Math.random()*0.6;
    obj.scale.multiplyScalar(s);
    const r = baseR * s * 0.9;

    // — garantili pozisyon — kümeyi bozmaz
    let pos = new THREE.Vector3();
    let ok = false;
    for(let tries=0; tries<100 && !ok; tries++){
      pos.set(
        (Math.random()*2-1)*cloudR,
        (Math.random()*2-1)*cloudR,
        (Math.random()*2-1)*cloudR
      );

      ok = true;
      for(let j=0;j<instances.length;j++){
        const dist = pos.distanceTo(instances[j].mesh.position);
        if(dist < (r + instances[j].radius)*0.95){ ok = false; break; }
      }
    }

    obj.position.copy(pos);
    scene.add(obj);

    instances.push({
      mesh: obj,
      radius: r,
      velocity: new THREE.Vector3(
        (Math.random()-0.5)*0.03,
        (Math.random()-0.5)*0.03,
        (Math.random()-0.5)*0.03
      ),
      rot: new THREE.Vector3(
        (Math.random()-0.5)*0.03,
        (Math.random()-0.5)*0.03,
        (Math.random()-0.5)*0.03
      ),
      noise: Math.random()*100
    });
  }
}

// =========================================================
// MOUSE INTERACTION  (SADE DARBE FİZİĞİ)
// =========================================================
const mouse = new THREE.Vector2();
const lastMouse = new THREE.Vector2();
const mouseVel = new THREE.Vector2();
let lastT = performance.now();

const plane = new THREE.Plane(new THREE.Vector3(0,0,1), 0);
const raycaster = new THREE.Raycaster();
const mouseWorld = new THREE.Vector3();

function updateMouseWorld(){
  raycaster.setFromCamera(mouse, camera);
  raycaster.ray.intersectPlane(plane, mouseWorld);
}

window.addEventListener("mousemove", e=>{
  const rect = renderer.domElement.getBoundingClientRect();
  const x = ((e.clientX - rect.left)/rect.width)*2 - 1;
  const y = -((e.clientY - rect.top)/rect.height)*2 + 1;
  mouse.set(x,y);

  const now = performance.now();
  const dt = (now-lastT)||16;
  mouseVel.set((x-lastMouse.x), (y-lastMouse.y)).divideScalar(dt);
  lastMouse.copy(mouse);
  lastT = now;

  updateMouseWorld();

  const speed = mouseVel.length();
  if(speed > 0.003){
    const force = speed*1.4;
    for(const inst of instances){
      const p = inst.mesh.position;
      const d = p.distanceTo(mouseWorld);
      const range = 2.4;
      if(d < range){
        const dir = p.clone().sub(mouseWorld).normalize();
        const f = force * (1 - d/range);
        inst.velocity.addScaledVector(dir, f*0.2);
      }
    }
  }
});

// =========================================================
// ANIMATION LOOP
// =========================================================
const center = new THREE.Vector3(0,0,0);
const clock = new THREE.Clock();

function animate(){
  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  const drag = 0.94;
  const spring = 0.25;
  const maxVel = 0.18;

  // — hareket güncelle
  for(const inst of instances){

    // merkeze hafif çekiş
    const toC = center.clone().sub(inst.mesh.position).multiplyScalar(spring*dt);
    inst.velocity.add(toC);

    // random noise hareketi
    const t = clock.elapsedTime + inst.noise;
    inst.velocity.x += Math.sin(t*1.3)*0.015*dt;
    inst.velocity.y += Math.cos(t*1.7)*0.015*dt;
    inst.velocity.z += Math.sin(t*1.1)*0.015*dt;

    inst.velocity.multiplyScalar(drag);

    if(inst.velocity.length()>maxVel){
      inst.velocity.setLength(maxVel);
    }

    inst.mesh.position.addScaledVector(inst.velocity, 1);

    inst.mesh.rotation.x += inst.rot.x*dt*5;
    inst.mesh.rotation.y += inst.rot.y*dt*5;
    inst.mesh.rotation.z += inst.rot.z*dt*5;
  }

  // — sphere–sphere çarpışma
  for(let i=0;i<instances.length;i++){
    for(let j=i+1;j<instances.length;j++){
      const a = instances[i];
      const b = instances[j];
      const pa = a.mesh.position;
      const pb = b.mesh.position;
      const diff = pb.clone().sub(pa);
      const dist = diff.length();
      const minD = a.radius + b.radius;

      if(dist>0 && dist<minD){
        const overlap = (minD - dist)*0.5;
        diff.normalize();
        pa.addScaledVector(diff,-overlap);
        pb.addScaledVector(diff,+overlap);
      }
    }
  }

  renderer.render(scene,camera);
}

// =========================================================
// RESIZE
// =========================================================
window.addEventListener("resize", ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>

</body>
</html>
