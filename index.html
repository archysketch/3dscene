<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Lusion Physics Prototype</title>
<style>
    html, body {
        margin: 0; padding: 0;
        overflow: hidden;
        background: #000;
    }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
// --------------------------------------------------
// SCENE & CAMERA
// --------------------------------------------------
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
    55, innerWidth / innerHeight, 0.1, 100
);
camera.position.set(0, 0, 22);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

// --------------------------------------------------
// LIGHT
// --------------------------------------------------
const hemi = new THREE.HemisphereLight(0xffffff, 0x000000, 1);
scene.add(hemi);

// --------------------------------------------------
// BALL MATERIALS (renkler buradan gelir)
// --------------------------------------------------
const palette = [
    0xff6b6b, // kırmızı
    0x4da6ff, // mavi
    0xffd86b, // sarı
    0xbd7bff, // mor
    0xff8ff2  // pembe
];

// --------------------------------------------------
// INSTANCING
// --------------------------------------------------
const COUNT = 40;
const positions = [];
const velocities = [];
const scales = [];
const drift = [];

const geometry = new THREE.SphereGeometry(1, 32, 32);

const materials = palette.map(c =>
    new THREE.MeshStandardMaterial({
        color: c,
        roughness: 0.25,
        metalness: 0.15
    })
);

// instanced için tek materyal gerekiyor → clone trick:
const instanced = new THREE.InstancedMesh(
    geometry,
    materials[0],
    COUNT
);
scene.add(instanced);

instanced.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

const temp = new THREE.Object3D();

// --------------------------------------------------
// INITIALIZE BALLS
// --------------------------------------------------
for (let i = 0; i < COUNT; i++) {

    positions[i] = new THREE.Vector3(
        (Math.random() - 0.5) * 10,
        (Math.random() - 0.5) * 6,
        (Math.random() - 0.5) * 6
    );

    velocities[i] = new THREE.Vector3(
        (Math.random() - 0.5) * 0.05,
        (Math.random() - 0.5) * 0.05,
        (Math.random() - 0.5) * 0.05
    );

    // ★ RANDOM SCALE
    scales[i] = 1.4 + Math.random() * 1.4;

    // ★ DRIFT (idle hareket)
    drift[i] = new THREE.Vector3(
        Math.random() * 10,
        Math.random() * 10,
        Math.random() * 10
    );
}

// --------------------------------------------------
// PHYSICS
// --------------------------------------------------
function updatePhysics(time) {

    const centerForce = 0.0015;
    const damping = 0.965;

    for (let i = 0; i < COUNT; i++) {

        // ★ SMOOTH IDLE DRIFT
        positions[i].x += Math.sin(time * 1.1 + drift[i].x) * 0.01;
        positions[i].y += Math.cos(time * 0.9 + drift[i].y) * 0.01;
        positions[i].z += Math.sin(time * 1.3 + drift[i].z) * 0.01;

        // center pull
        velocities[i].addScaledVector(positions[i], -centerForce);

        // collisions
        for (let j = i + 1; j < COUNT; j++) {

            const diff = positions[i].clone().sub(positions[j]);
            const dist = diff.length();

            const minDist = scales[i] + scales[j] + 0.3;

            if (dist < minDist && dist > 0) {
                const force = (minDist - dist) * 0.02;
                diff.normalize();
                velocities[i].addScaledVector(diff, force);
                velocities[j].addScaledVector(diff, -force);
            }
        }

        velocities[i].multiplyScalar(damping);
        positions[i].add(velocities[i]);
    }
}

// --------------------------------------------------
// MOUSE FORCE
// --------------------------------------------------
let mouse = new THREE.Vector3();

window.addEventListener("pointermove", e => {
    const x = (e.clientX / innerWidth) * 2 - 1;
    const y = -(e.clientY / innerHeight) * 2 + 1;
    mouse.set(x * 10, y * 6, 0);
});

function applyMouseForce() {

    const radius = 5;
    const force = 0.06;

    for (let i = 0; i < COUNT; i++) {
        const diff = positions[i].clone().sub(mouse);
        const dist = diff.length();

        if (dist < radius) {
            velocities[i].add(diff.normalize().multiplyScalar((radius - dist) * force));
        }
    }
}

// --------------------------------------------------
// RENDER LOOP
// --------------------------------------------------
function animate(t) {

    const time = t * 0.001;

    applyMouseForce();
    updatePhysics(time);

    for (let i = 0; i < COUNT; i++) {

        temp.position.copy(positions[i]);
        temp.scale.set(scales[i], scales[i], scales[i]);

        temp.updateMatrix();
        instanced.setMatrixAt(i, temp.matrix);
    }

    instanced.instanceMatrix.needsUpdate = true;

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}
animate();

// --------------------------------------------------
window.addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
