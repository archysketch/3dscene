<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Lusion GLB Physics</title>
<style>
html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #000;
}
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/loaders/GLTFLoader.js"></script>

<script>
// ------------------------------------
// SCENE & CAMERA
// ------------------------------------
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 100);
camera.position.set(0, 0, 24);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

// ------------------------------------
// LIGHT
// ------------------------------------
scene.add(new THREE.HemisphereLight(0xffffff, 0x222222, 1.2));

// ------------------------------------
// PHYSICS DATA
// ------------------------------------
const COUNT = 40;
const positions = [];
const velocities = [];
const rotations = [];

for (let i = 0; i < COUNT; i++) {
    positions[i] = new THREE.Vector3(
        (Math.random() - 0.5) * 12,
        (Math.random() - 0.5) * 7,
        (Math.random() - 0.5) * 7
    );

    velocities[i] = new THREE.Vector3(
        (Math.random() - 0.5) * 0.04,
        (Math.random() - 0.5) * 0.04,
        (Math.random() - 0.5) * 0.04
    );

    rotations[i] = new THREE.Vector3(
        Math.random(),
        Math.random(),
        Math.random()
    );
}

// ------------------------------------
// MOUSE
// ------------------------------------
let mouse = new THREE.Vector3();
window.addEventListener("pointermove", (e) => {
    const x = (e.clientX / innerWidth) * 2 - 1;
    const y = -(e.clientY / innerHeight) * 2 + 1;
    mouse.set(x * 9, y * 6, 0);
});

// ------------------------------------
// PHYSICS TUNING
// ------------------------------------
const CENTER_FORCE = 0.0007;
const RETURN_DAMPING = 0.97;

const BASE_MOUSE_FORCE = 0.045;
const INTERACTION_MULTIPLIER = 2;
const MOUSE_RADIUS = 9;

const REPEL_RADIUS = 5.4;
const REPEL_STRENGTH = 0.011;

// ------------------------------------
// LOAD GLB & CREATE INSTANCES
// ------------------------------------
const loader = new THREE.GLTFLoader();
let instanced, temp = new THREE.Object3D();

loader.load(
    "https://raw.githubusercontent.com/archysketch/3dscene/main/christmas_ball.glb",
    (gltf) => {

        let sourceMesh;
        gltf.scene.traverse((child) => {
            if (child.isMesh) sourceMesh = child;
        });

        sourceMesh.geometry.center();
        sourceMesh.geometry.computeVertexNormals();

        instanced = new THREE.InstancedMesh(
            sourceMesh.geometry,
            sourceMesh.material,
            COUNT
        );

        scene.add(instanced);
        animate();
    }
);

// ------------------------------------
// FORCES
// ------------------------------------
function applyMouseForce() {
    for (let i = 0; i < COUNT; i++) {
        const diff = positions[i].clone().sub(mouse);
        const dist = diff.length();

        if (dist < MOUSE_RADIUS) {
            const push =
                Math.pow(MOUSE_RADIUS - dist, 2) *
                BASE_MOUSE_FORCE *
                INTERACTION_MULTIPLIER;

            diff.normalize();
            velocities[i].add(diff.multiplyScalar(push));
        }
    }
}

function updatePhysics() {

    for (let i = 0; i < COUNT; i++) {

        velocities[i].x -= positions[i].x * CENTER_FORCE;
        velocities[i].y -= positions[i].y * CENTER_FORCE;
        velocities[i].z -= positions[i].z * CENTER_FORCE;

        for (let j = i + 1; j < COUNT; j++) {
            const diff = positions[i].clone().sub(positions[j]);
            const dist = diff.length();

            if (dist < REPEL_RADIUS && dist > 0) {

                const speed =
                    velocities[i].length() +
                    velocities[j].length();

                const speedDamp = THREE.MathUtils.clamp(
                    1 - speed * 2,
                    0.25,
                    1
                );

                const push =
                    (REPEL_RADIUS - dist) *
                    REPEL_STRENGTH *
                    speedDamp;

                diff.normalize();
                velocities[i].add(diff.clone().multiplyScalar(push));
                velocities[j].add(diff.clone().multiplyScalar(-push));
            }
        }

        velocities[i].multiplyScalar(RETURN_DAMPING);
        positions[i].add(velocities[i]);

        // ROTATION (this fixes the "2D" feeling)
        rotations[i].x += velocities[i].y * 0.5;
        rotations[i].y += velocities[i].x * 0.5;
        rotations[i].z += velocities[i].z * 0.5;
    }
}

// ------------------------------------
// RENDER LOOP
// ------------------------------------
function animate() {

    applyMouseForce();
    updatePhysics();

    for (let i = 0; i < COUNT; i++) {
        temp.position.copy(positions[i]);
        temp.rotation.set(
            rotations[i].x,
            rotations[i].y,
            rotations[i].z
        );
        temp.scale.setScalar(1); // GLB scale
        temp.updateMatrix();
        instanced.setMatrixAt(i, temp.matrix);
    }

    instanced.instanceMatrix.needsUpdate = true;

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}

// ------------------------------------
window.addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
