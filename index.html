<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Scene – Bubbles</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at 50% 0%,
        #14274b 0%,
        #02030a 50%,
        #000000 100%);
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
<canvas id="webgl"></canvas>

<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
  import { GLTFLoader } from 'https://unpkg.com/three@0.161.0/examples/jsm/loaders/GLTFLoader.js';

  // === Temel sahne ===
  const canvas = document.getElementById('webgl');
  const renderer = new THREE.WebGLRenderer({
    canvas,
    antialias: true,
    alpha: true
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.outputEncoding = THREE.sRGBEncoding;

  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(
    35,
    window.innerWidth / window.innerHeight,
    0.1,
    100
  );
  camera.position.set(0, 1.2, 8);
  scene.add(camera);

  // Işıklar
  const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 1.2);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 1.8);
  dir.position.set(5, 8, 5);
  dir.castShadow = true;
  scene.add(dir);

  // Objeleri tutacak grup
  const group = new THREE.Group();
  scene.add(group);

  const loader = new GLTFLoader();

  function addDebugSphere(x) {
    const geo = new THREE.SphereGeometry(0.6, 32, 32);
    const mat = new THREE.MeshStandardMaterial({
      color: 0xff5566,
      metalness: 0.1,
      roughness: 0.4
    });
    const m = new THREE.Mesh(geo, mat);
    m.position.set(x, 0, 0);
    group.add(m);
  }

  function loadBall(url, offsetX = 0) {
    loader.load(
      url,
      (gltf) => {
        const root = gltf.scene;

        // Bounding box al – normalize et
        const box = new THREE.Box3().setFromObject(root);
        const size = new THREE.Vector3();
        box.getSize(size);
        const maxDim = Math.max(size.x, size.y, size.z) || 1;

        // Sahneye göre ölçekle
        const desiredSize = 2.0; // kabaca çap ~2 birim
        const scale = desiredSize / maxDim;
        root.scale.setScalar(scale);

        // Merkeze hizala
        const center = new THREE.Vector3();
        box.getCenter(center);
        root.position.sub(center); // origin’e taşır
        root.position.x += offsetX;

        // Materyalleri biraz görünür hale getir
        root.traverse((obj) => {
          if (obj.isMesh) {
            obj.castShadow = true;
            obj.receiveShadow = true;
            if (obj.material) {
              obj.material.metalness = 0.25;
              obj.material.roughness = 0.4;
              obj.material.needsUpdate = true;
            }
          }
        });

        group.add(root);
      },
      undefined,
      (err) => {
        console.error('GLB yüklenemedi:', url, err);
        // Yüklenmezse debug için bir küre koy
        addDebugSphere(offsetX);
      }
    );
  }

  // GLB dosyalarını yükle
  // Dosya adları repo kökündekiyle birebir aynı olmalı
  loadBall('./christmas_ball.glb', -1.8);
  loadBall('./christmas_tree_ball.glb', 1.8);

  // === Mouse etkileşimi ===
  let targetRotX = 0, targetRotY = 0;
  let rotX = 0, rotY = 0;

  window.addEventListener('pointermove', (e) => {
    const x = (e.clientX / window.innerWidth) * 2 - 1;  // -1..1
    const y = (e.clientY / window.innerHeight) * 2 - 1;

    targetRotY = x * 0.8;  // yatayda daha fazla dönsün
    targetRotX = y * 0.5;
  });

  // Basit "fizik" hareketi
  let t = 0;

  function animate() {
    requestAnimationFrame(animate);

    t += 0.01;
    // Yumuşak easing
    rotX += (targetRotX - rotX) * 0.06;
    rotY += (targetRotY - rotY) * 0.06;

    group.rotation.set(rotX, rotY, 0);
    // Hafif yukarı-aşağı salınım
    group.position.y = Math.sin(t) * 0.3;

    renderer.render(scene, camera);
  }

  animate();

  // Resize
  window.addEventListener('resize', () => {
    const w = window.innerWidth;
    const h = window.innerHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  });
</script>
</body>
</html>
