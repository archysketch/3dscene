<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Lusion Physics v3</title>
<style>
  html, body { margin: 0; padding: 0; overflow: hidden; background: black; }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
// --------------------------------------------------
// SCENE
// --------------------------------------------------
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 200);
camera.position.set(0, 0, 35);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

// --------------------------------------------------
// LIGHT
// --------------------------------------------------
scene.add(new THREE.HemisphereLight(0x4466ff, 0x000000, 1.1));

// --------------------------------------------------
// PARAMETRELER
// --------------------------------------------------
const COUNT = 40;
const SCALE = 2.5;          // ðŸŸ¢ TOP BOYUTU = 2.5X
const RADIUS = SCALE * 1.1; // Ã§arpÄ±ÅŸma yarÄ±Ã§apÄ±
const CENTER_PULL = 0.002;
const DAMPING = 0.92;
const REPEL_FORCE = 0.045;  // ðŸŸ¢ Ä°TME GÃœÃ‡LENDÄ°RÄ°LDÄ°
const REPEL_DISTANCE = RADIUS * 2.2; // ðŸŸ¢ SIFIR Ä°Ã‡ Ä°Ã‡E

// --------------------------------------------------
// INSTANCED BALLS
// --------------------------------------------------
const geometry = new THREE.SphereGeometry(RADIUS, 32, 32);
const material = new THREE.MeshStandardMaterial({
  color: 0x3e52ff,
  roughness: 0.24,
  metalness: 0.2
});

const balls = new THREE.InstancedMesh(geometry, material, COUNT);
scene.add(balls);

const pos = [];
const vel = [];
const drift = [];
const temp = new THREE.Object3D();

// --------------------------------------------------
// INITIAL POSITIONS
// --------------------------------------------------
for (let i = 0; i < COUNT; i++) {
  pos[i] = new THREE.Vector3(
    (Math.random() - 0.5) * 14,
    (Math.random() - 0.5) * 10,
    (Math.random() - 0.5) * 10
  );

  vel[i] = new THREE.Vector3(
    (Math.random() - 0.5) * 0.02,
    (Math.random() - 0.5) * 0.02,
    (Math.random() - 0.5) * 0.02
  );

  // idle drift
  drift[i] = new THREE.Vector3(
    (Math.random() - 0.5) * 0.008,
    (Math.random() - 0.5) * 0.008,
    (Math.random() - 0.5) * 0.008
  );
}

// --------------------------------------------------
// MOUSE FORCE
// --------------------------------------------------
let mouse = new THREE.Vector3();
window.addEventListener("pointermove", (e) => {
  const x = (e.clientX / innerWidth) * 2 - 1;
  const y = -(e.clientY / innerHeight) * 2 + 1;
  mouse.set(x * 10, y * 6, 0);
});

function applyMouseForce() {
  for (let i = 0; i < COUNT; i++) {
    const diff = pos[i].clone().sub(mouse);
    const dist = diff.length();

    if (dist < 6) {
      diff.normalize();
      vel[i].add(diff.multiplyScalar((6 - dist) * 0.04));
    }
  }
}

// --------------------------------------------------
// PHYSICS UPDATE
// --------------------------------------------------
function updatePhysics() {

  // SÃœREKLÄ° KÃœÃ‡ÃœK DRIFT
  for (let i = 0; i < COUNT; i++) {
    pos[i].add(drift[i]);
  }

  // Ã‡Ä°FT TARAFLI Ä°TÄ°Åž
  for (let i = 0; i < COUNT; i++) {
    for (let j = i + 1; j < COUNT; j++) {
      const diff = pos[i].clone().sub(pos[j]);
      const dist = diff.length();

      if (dist < REPEL_DISTANCE && dist > 0) {
        const push = (REPEL_DISTANCE - dist) * REPEL_FORCE;
        diff.normalize();

        vel[i].add(diff.clone().multiplyScalar(push));
        vel[j].add(diff.clone().multiplyScalar(-push));
      }
    }
  }

  // MERKEZE DOÄžRU YUMUÅžAK Ã‡EKÄ°M
  for (let i = 0; i < COUNT; i++) {
    vel[i].x -= pos[i].x * CENTER_PULL;
    vel[i].y -= pos[i].y * CENTER_PULL;
    vel[i].z -= pos[i].z * CENTER_PULL;

    vel[i].multiplyScalar(DAMPING);
    pos[i].add(vel[i]);
  }
}

// --------------------------------------------------
// ORBIT DRIFT â€” tÃ¼m sahne kendi ekseninde dÃ¶nsÃ¼n
// --------------------------------------------------
let orbitGroup = new THREE.Group();
scene.add(orbitGroup);
orbitGroup.add(balls);

function updateOrbit() {
  orbitGroup.rotation.y += 0.0018;
  orbitGroup.rotation.x += 0.0007;
}

// --------------------------------------------------
// ANIMATE
// --------------------------------------------------
function animate() {

  applyMouseForce();
  updatePhysics();
  updateOrbit(); // ðŸŸ¢ SAHNE HEP DÃ–NÃœYOR

  // Instanced Mesh pozisyonlarÄ± gÃ¼ncelle
  for (let i = 0; i < COUNT; i++) {
    temp.position.copy(pos[i]);
    temp.updateMatrix();
    balls.setMatrixAt(i, temp.matrix);
  }
  balls.instanceMatrix.needsUpdate = true;

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

// --------------------------------------------------
window.addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
