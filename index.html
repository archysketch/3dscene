<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>3D Scene – Bouncy GLB Balls</title>
  <style>
    html,body{
      margin:0;
      padding:0;
      overflow:hidden;
      height:100%;
      background:
        radial-gradient(circle at 50% 0%, #1e3d72 0%, #050713 55%, #000000 100%);
    }
    canvas{display:block;}
    #hint{
      position:fixed;
      left:50%;
      bottom:16px;
      transform:translateX(-50%);
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      font-size:10px;
      letter-spacing:0.18em;
      text-transform:uppercase;
      color:rgba(255,255,255,0.4);
      pointer-events:none;
    }
  </style>
</head>
<body>

  <div id="hint">MOVE MOUSE · DRAG · SCROLL</div>

  <!-- three.js (r126, global THREE) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.126.1/build/three.min.js"></script>
  <!-- GLTFLoader (aynı sürüm, THREE.GLTFLoader olarak) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.126.1/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    // ===== SCENE / CAMERA / RENDERER =====
    var scene = new THREE.Scene();

    var camera = new THREE.PerspectiveCamera(
      35,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    camera.position.set(0, 0, 18);

    var renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.setClearColor(0x000000, 0);
    document.body.appendChild(renderer.domElement);

    // ===== LIGHTS (daha düz, uzaklaşınca kararmasın) =====
    var hemi = new THREE.HemisphereLight(0x88aaff, 0x050506, 0.7);
    scene.add(hemi);

    var keyLight = new THREE.DirectionalLight(0xffffff, 1.4);
    keyLight.position.set(6, 8, 10);
    scene.add(keyLight);

    var rimLight = new THREE.PointLight(0x3c7bff, 2.3, 80);
    rimLight.position.set(-7, -3, 8);
    scene.add(rimLight);

    // ===== GROUP & “PHYSICS” =====
    var group = new THREE.Group();
    scene.add(group);

    var bodies = []; // { mesh, velocity, baseVel }
    var bounds = { x: 9.0, y: 5.0, z: 5.0 };

    var loader = new THREE.GLTFLoader();

    function createBodiesFromGLTF(gltf, count, baseScale, spread) {
      for (var i = 0; i < count; i++) {
        var clone = gltf.scene.clone(true);

        clone.traverse(function(obj){
          if (obj.isMesh && obj.material) {
            obj.castShadow = false;
            obj.receiveShadow = false;
            obj.material.metalness = 0.45;
            obj.material.roughness = 0.25;
          }
        });

        var s = baseScale * (0.7 + Math.random() * 0.8);
        clone.scale.set(s, s, s);

        clone.position.set(
          (Math.random() * 2 - 1) * spread.x,
          (Math.random() * 2 - 1) * spread.y,
          (Math.random() * 2 - 1) * spread.z
        );

        group.add(clone);

        var baseVel = new THREE.Vector3(
          (Math.random() * 2 - 1) * 0.015,
          (Math.random() * 2 - 1) * 0.015,
          (Math.random() * 2 - 1) * 0.015
        );

        bodies.push({
          mesh: clone,
          velocity: baseVel.clone(),
          baseVel: baseVel
        });
      }
    }

    // ===== GLB LOAD =====
    var assetsLoaded = 0;
    var TOTAL_ASSETS = 2;

    loader.load(
      "christmas_ball.glb",
      function(gltf){
        createBodiesFromGLTF(
          gltf,
          10,
          0.9,
          { x: 5.5, y: 3.0, z: 3.0 }
        );
        assetsLoaded++;
        if (assetsLoaded === TOTAL_ASSETS) start();
      },
      undefined,
      function(err){ console.error("Ball load ERROR:", err); }
    );

    loader.load(
      "christmas_tree_ball.glb",
      function(gltf){
        createBodiesFromGLTF(
          gltf,
          8,
          1.1,
          { x: 5.0, y: 2.8, z: 3.0 }
        );
        assetsLoaded++;
        if (assetsLoaded === TOTAL_ASSETS) start();
      },
      undefined,
      function(err){ console.error("Tree load ERROR:", err); }
    );

    // ===== MOUSE / SCROLL =====
    var mouseNorm = new THREE.Vector2(0, 0); // parallax için
    var scrollOffset = 0;

    // impulse için world pozisyonu
    function mouseToWorld(){
      // Lusion’daki gibi z≈0 düzlemi etrafında kümeliyoruz
      return new THREE.Vector3(
        mouseNorm.x * 6.0,
        -mouseNorm.y * 4.0,
        0
      );
    }

    window.addEventListener("pointermove", function(e){
      var x = (e.clientX / window.innerWidth) * 2 - 1;
      var y = (e.clientY / window.innerHeight) * 2 - 1;
      mouseNorm.set(x, y);

      applyMouseImpulse();
    });

    window.addEventListener("wheel", function(e){
      scrollOffset += e.deltaY * 0.0007;
      scrollOffset = Math.max(-2, Math.min(2, scrollOffset));
    }, { passive:true });

    // ===== MOUSE IMPULSE (hareket edince vurma efekti) =====
    function applyMouseImpulse(){
      if (!bodies.length) return;

      var mousePos = mouseToWorld();
      var radius = 4.0;

      for (var i = 0; i < bodies.length; i++){
        var b = bodies[i];
        var m = b.mesh;

        var delta = m.position.clone().sub(mousePos);
        var dist = delta.length();
        if (dist === 0 || dist > radius) continue;

        var falloff = 1 - dist / radius;           // yakındakiler daha çok etkilenir
        delta.normalize();

        var strength = 1.4 * falloff;              // vurma gücü
        b.velocity.addScaledVector(delta, strength);
      }
    }

    // ===== ANIMATION LOOP =====
    var lastTime = performance.now();
    var running = false;

    function start(){
      if (!running){
        running = true;
        lastTime = performance.now();
        animate();
      }
    }

    function animate(){
      requestAnimationFrame(animate);
      if (!running) return;

      var now = performance.now();
      var dt = Math.min(0.04, (now - lastTime) / 1000);
      lastTime = now;

      updatePhysics(dt);
      updateCamera(dt);

      renderer.render(scene, camera);
    }

    function updatePhysics(dt){
      var damping = 0.985;
      var centerSpring = 0.35;   // merkeze hafif yay kuvveti
      var jitter = 0.004;        // random noise

      for (var i = 0; i < bodies.length; i++){
        var b = bodies[i];
        var m = b.mesh;
        var v = b.velocity;

        // hafif kendi etrafında dönsün
        m.rotation.y += 0.45 * dt;
        m.rotation.x += 0.18 * dt;

        // temel drift (baseVel etrafında)
        v.addScaledVector(b.baseVel, 0.2);

        // merkeze doğru mini yay (drift edip dağılmasınlar)
        var toCenter = m.position.clone().multiplyScalar(-1);
        v.addScaledVector(toCenter, centerSpring * dt);

        // küçük random gürültü – organik hareket
        v.x += (Math.random() - 0.5) * jitter;
        v.y += (Math.random() - 0.5) * jitter;
        v.z += (Math.random() - 0.5) * jitter;

        // damping
        v.multiplyScalar(damping);

        // pozisyon güncelle
        m.position.addScaledVector(v, dt * 60);

        // bounds & sekme
        if (m.position.x < -bounds.x){ m.position.x = -bounds.x; v.x *= -0.9; }
        if (m.position.x >  bounds.x){ m.position.x =  bounds.x; v.x *= -0.9; }
        if (m.position.y < -bounds.y){ m.position.y = -bounds.y; v.y *= -0.9; }
        if (m.position.y >  bounds.y){ m.position.y =  bounds.y; v.y *= -0.9; }
        if (m.position.z < -bounds.z){ m.position.z = -bounds.z; v.z *= -0.9; }
        if (m.position.z >  bounds.z){ m.position.z =  bounds.z; v.z *= -0.9; }
      }
    }

    function updateCamera(dt){
      // mouse’a göre grup eğimi (parallax)
      var tiltX = mouseNorm.y * 0.35;
      var tiltY = mouseNorm.x * 0.55;

      group.rotation.x += (tiltX - group.rotation.x) * 0.06;
      group.rotation.y += (tiltY - group.rotation.y) * 0.06;

      // scroll ile zoom ama ışık/fog değişmediği için kararmıyor
      var targetZ = 18 + scrollOffset * 3;
      camera.position.z += (targetZ - camera.position.z) * 0.06;
      camera.lookAt(0, 0, 0);
    }

    // ===== RESIZE =====
    window.addEventListener("resize", function () {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
