<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Lusion-Style Floating Ornaments</title>

<style>
    html,body{
        margin:0;
        padding:0;
        overflow:hidden;
        height:100%;
        background: radial-gradient(circle at 50% 0%, #1e3d72 0%, #050713 55%, #000000 100%);
    }
    canvas { display:block; }
    #hint{
        position:fixed;
        left:50%;
        bottom:16px;
        transform:translateX(-50%);
        font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
        font-size:10px;
        letter-spacing:0.18em;
        text-transform:uppercase;
        color:rgba(255,255,255,0.4);
        pointer-events:none;
    }
</style>
</head>

<body>
<div id="hint">MOVE MOUSE · DRAG · SCROLL</div>

<!-- THREE.js (r126) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.126.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.126.1/examples/js/loaders/GLTFLoader.js"></script>

<script>
/* ============================================================
   SCENE SETUP
============================================================ */
let scene = new THREE.Scene();

let camera = new THREE.PerspectiveCamera(
    35,
    window.innerWidth / window.innerHeight,
    0.1,
    100
);
camera.position.set(0,0,18);

let renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.outputEncoding = THREE.sRGBEncoding;
document.body.appendChild(renderer.domElement);

/* ============================================================
   LIGHTS
============================================================ */
scene.add(new THREE.HemisphereLight(0x88aaff, 0x050506, 0.7));

let keyLight = new THREE.DirectionalLight(0xffffff, 1.4);
keyLight.position.set(6, 8, 10);
scene.add(keyLight);

let rim = new THREE.PointLight(0x3c7bff, 2.2, 80);
rim.position.set(-7, -3, 8);
scene.add(rim);

/* ============================================================
   GROUP + LOADER
============================================================ */
let group = new THREE.Group();
scene.add(group);

let loader = new THREE.GLTFLoader();
let bodies = [];   // { mesh, velocity }

/* ============================================================
   LOAD GLBs
============================================================ */
let assetsLoaded = 0;
const TOTAL = 2;

// BALLS
loader.load("christmas_ball.glb", gltf=>{
    spawn(gltf, 10, 0.9, {x:5,y:3,z:3});
    checkStart();
});

// TREE BALLS
loader.load("christmas_tree_ball.glb", gltf=>{
    spawn(gltf, 8, 1.1, {x:5,y:3,z:3});
    checkStart();
});

function checkStart(){
    assetsLoaded++;
    if(assetsLoaded === TOTAL) start();
}

/* Spawn clones */
function spawn(gltf, count, scale, spread){
    for(let i=0;i<count;i++){
        let m = gltf.scene.clone(true);

        m.traverse(obj=>{
            if(obj.isMesh){
                obj.material.metalness = 0.45;
                obj.material.roughness = 0.25;
            }
        });

        let s = scale * (0.7 + Math.random()*0.8);
        m.scale.set(s,s,s);

        m.position.set(
            (Math.random()*2-1)*spread.x,
            (Math.random()*2-1)*spread.y,
            (Math.random()*2-1)*spread.z
        );

        group.add(m);

        bodies.push({
            mesh: m,
            velocity: new THREE.Vector3()
        });
    }
}

/* ============================================================
   MOUSE
============================================================ */
let mouseNorm = new THREE.Vector2(0,0);
let scrollOffset = 0;

window.addEventListener("pointermove", e=>{
    mouseNorm.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouseNorm.y = (e.clientY / window.innerHeight) * 2 - 1;
});

window.addEventListener("wheel", e=>{
    scrollOffset += e.deltaY * 0.0007;
    scrollOffset = Math.max(-2, Math.min(2, scrollOffset));
},{passive:true});

/* ============================================================
   PHYSICS — LUSION STYLE
============================================================ */
function updatePhysics(dt){
    const R = 5.5;              // spherical shell radius
    const repelDist = 1.9;      // minimum distance
    const repelForce = 0.12;    // strong local collision
    const shellForce = 0.25;    // spherical constraint
    const driftForce = 0.04;    // random drift
    const damping = 0.90;       // velocity smoothing

    let mouseWorld = new THREE.Vector3(
        mouseNorm.x * 4,
        -mouseNorm.y * 3,
        0
    );

    // COLLISION / REPULSION
    for(let i=0;i<bodies.length;i++){
        for(let j=i+1;j<bodies.length;j++){
            let bi = bodies[i], bj = bodies[j];
            let p1 = bi.mesh.position;
            let p2 = bj.mesh.position;

            let diff = p1.clone().sub(p2);
            let dist = diff.length();

            if(dist < repelDist && dist > 0){
                let push = (repelDist - dist) * repelForce;
                diff.normalize();
                bi.velocity.addScaledVector(diff, push);
                bj.velocity.addScaledVector(diff, -push);
            }
        }
    }

    // INDIVIDUAL MOTION
    for(let b of bodies){
        let p = b.mesh.position;
        let v = b.velocity;

        // random drift
        v.x += (Math.random()-0.5) * driftForce;
        v.y += (Math.random()-0.5) * driftForce;
        v.z += (Math.random()-0.5) * driftForce;

        // spherical shell
        let radial = p.length();
        if(radial > 0){
            let diff = radial - R;
            let n = p.clone().normalize();
            v.addScaledVector(n, -diff * shellForce);
        }

        // mouse effect
        let d = p.clone().sub(mouseWorld);
        let md = d.length();
        if(md < 3 && md > 0){
            d.normalize();
            v.addScaledVector(d, (3-md)*0.05);
        }

        // damping
        v.multiplyScalar(damping);

        // update position
        p.addScaledVector(v, dt * 60);

        // rotation
        b.mesh.rotation.x += 0.25 * dt;
        b.mesh.rotation.y += 0.35 * dt;
    }
}

/* ============================================================
   LOOP
============================================================ */
let running = false;
let last = performance.now();

function start(){
    if(!running){
        running = true;
        animate();
    }
}

function animate(){
    requestAnimationFrame(animate);

    if(!running) return;

    let now = performance.now();
    let dt = Math.min(0.04, (now-last)/1000);
    last = now;

    updatePhysics(dt);
    updateCamera(dt);

    renderer.render(scene, camera);
}

/* Camera smooth follow */
function updateCamera(dt){
    let tiltX = mouseNorm.y * 0.35;
    let tiltY = mouseNorm.x * 0.55;

    group.rotation.x += (tiltX - group.rotation.x) * 0.06;
    group.rotation.y += (tiltY - group.rotation.y) * 0.06;

    let targetZ = 18 + scrollOffset * 3;
    camera.position.z += (targetZ - camera.position.z) * 0.06;
    camera.lookAt(0,0,0);
}

/* Resize */
window.addEventListener("resize", ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
