<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>GLB Instanced Test</title>
<style>
html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #000;
}
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/loaders/GLTFLoader.js"></script>

<script>
// ------------------------------------
// SCENE
// ------------------------------------
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 100);
camera.position.set(0, 0, 25);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

// ------------------------------------
// LIGHT (STRONG ON PURPOSE)
// ------------------------------------
scene.add(new THREE.AmbientLight(0xffffff, 1.2));

const dir = new THREE.DirectionalLight(0xffffff, 1.5);
dir.position.set(5, 10, 10);
scene.add(dir);

// ------------------------------------
// PHYSICS DATA
// ------------------------------------
const COUNT = 40;
const positions = [];
const velocities = [];
const rotations = [];

for (let i = 0; i < COUNT; i++) {
    positions[i] = new THREE.Vector3(
        (Math.random() - 0.5) * 12,
        (Math.random() - 0.5) * 8,
        (Math.random() - 0.5) * 8
    );

    velocities[i] = new THREE.Vector3(
        (Math.random() - 0.5) * 0.04,
        (Math.random() - 0.5) * 0.04,
        (Math.random() - 0.5) * 0.04
    );

    rotations[i] = new THREE.Vector3();
}

// ------------------------------------
// LOAD GLB
// ------------------------------------
const loader = new THREE.GLTFLoader();
let instanced;
const temp = new THREE.Object3D();

loader.load(
    "https://raw.githubusercontent.com/archysketch/3dscene/main/christmas_ball.glb",
    (gltf) => {

        let mesh;
        gltf.scene.traverse((c) => {
            if (c.isMesh) mesh = c;
        });

        // ðŸ”‘ CRITICAL FIXES
        mesh.geometry.center();
        mesh.geometry.computeVertexNormals();

        // DEBUG MATERIAL (guaranteed visible)
        const material = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            metalness: 0.2,
            roughness: 0.3
        });

        instanced = new THREE.InstancedMesh(
            mesh.geometry,
            material,
            COUNT
        );

        scene.add(instanced);
        animate();
    },
    undefined,
    (err) => console.error("GLB load error", err)
);

// ------------------------------------
// SIMPLE PHYSICS
// ------------------------------------
function update() {
    for (let i = 0; i < COUNT; i++) {
        positions[i].add(velocities[i]);

        velocities[i].multiplyScalar(0.98);

        rotations[i].x += velocities[i].y;
        rotations[i].y += velocities[i].x;
    }
}

// ------------------------------------
// RENDER LOOP
// ------------------------------------
function animate() {

    update();

    for (let i = 0; i < COUNT; i++) {
        temp.position.copy(positions[i]);
        temp.rotation.set(
            rotations[i].x,
            rotations[i].y,
            rotations[i].z
        );

        // ðŸ”¥ THIS IS THE KEY LINE
        temp.scale.setScalar(8); // <<<<<<<<<<<<<<

        temp.updateMatrix();
        instanced.setMatrixAt(i, temp.matrix);
    }

    instanced.instanceMatrix.needsUpdate = true;

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}

window.addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
